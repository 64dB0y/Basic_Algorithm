'''
1. 왕, 돌의 초기 위치 및 이동 횟수를 입력받음
2. 왕의 위치를 숫자로 변환, 단 리스트의 첫번째 문자는 유니코드로 변환 (알파벳 A가 65니까 64를 뺀다)
3. 돌의 위치를 숫자로 변환, 단 리스트의 첫번째 문자는 유니코드로 변환 (알파벳 A가 65니까 64를 뺀다)
4. 각 이동을 딕셔너리로 저장
5. 이제부터 N번 이동한다.
    5-1 이동 후 왕의 x, y 좌표를 먼저 계산한다. (단, 체스판 내에서만 이동이 되는지 확인해야한다)
    5-2 이동한다면 왕과 돌이 겹치는지도 확인해야 하므로 (돌의 이동 후 좌표를 확인한다)
    5-3 돌이 체스판을 벗어나지 않으면 왕과 돌 모두 이동하지만 왕이 이동해도 돌과 겹쳐지지 않으면 왕만 이동
'''
#!/usr/bin/env python3
# 왕과 돌의 초기 위치와 이동 횟수를 입력받음
king, stone, N = input().split()
# 왕의 위치를 숫자로 변환하여 리스트에 저장
k = list(map(int, [ord(king[0]) - 64, king[1]]))
# 돌의 위치를 숫자로 변환하여 리스트에 저장
s = list(map(int, [ord(stone[0]) - 64, stone[1]]))
# 각 이동 방향에 따른 좌표 변화량을 딕셔너리로 저장
move = {'R': [1, 0], 'L': [-1, 0], 'B': [0, -1], 'T': [0, 1], 'RT': [1, 1], 'LT': [-1, 1], 'RB': [1, -1], 'LB': [-1, -1]}

# N번 이동
for _ in range(int(N)):
    # 이동 방향을 입력받음
    m = input()
    # 이동 후 왕의 x좌표
    nx = k[0] + move[m][0]
    # 이동 후 왕의 y좌표
    ny = k[1] + move[m][1]
    # 왕이 체스판을 벗어나지 않는 경우
    if 0 < nx <= 8 and 0 < ny <= 8:
        # 왕이 돌과 겹치는 경우
        if nx == s[0] and ny == s[1]:
            # 돌의 이동 후 x좌표
            sx = s[0] + move[m][0]
            # 돌의 이동 후 y좌표
            sy = s[1] + move[m][1]
            # 돌이 체스판을 벗어나지 않는 경우
            if 0 < sx <= 8 and 0 < sy <= 8:
                # 왕과 돌 모두 이동
                k = [nx, ny]
                s = [sx, sy]
        else:
            # 왕만 이동
            k = [nx, ny]
# 최종 왕의 위치 출력
print(f'{chr(k[0] + 64)}{k[1]}')
# 최종 돌의 위치 출력
print(f'{chr(s[0] + 64)}{s[1]}')