다이나믹 프로그래밍(Dynamic Programming) 정의

복잡한 문제를 여러 개의 작은 하위 문제로 나누어 풀고, 그 결과를 저장함으로써 중복 계산을 피하여 전체 문제를 효율적으로 해결하는 방법입니다. 

각 하위 문제의 해답은 한 번만 계산되며, 이후에는 저장된 해답을 재사용함으로써 계산 시간을 크게 줄일 수 있습니다. 이 방식은 주로 최적화 문제에서 사용되며, 하위 문제의 중복이 많고, 작은 문제의 해답을 조합하여 전체 문제의 해답을 구할 수 있는 경우에 유용합니다. 다이나믹 프로그래밍은 '메모이제이션' 또는 '하향식 접근법'과 '타뷸레이션' 또는 '상향식 접근법'을 포함한 다양한 기법을 사용합니다.

위의 정의에 따라 아래의 조건을 만족할 때만 사용한다.

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

메모이제이션 혹은 캐싱: 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법

# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0]*100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑 다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료조건(1 혹은 2일때 1을 반환)
    if x ==1 or x ==2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] !=0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x]= fibo(x-1)+fibo(x-2)
    return d[x]

print(fibo(99))

재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑 다운 방식이라고 한다.

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 (Fibonacci Function) 반복문으로 구현(바텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i] = d[i-1]+d[i-2]

print(d[n])

반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근 차근 답을 도출한다고 하여 바텀 업 방식이라고 한다.

(가능하면 바텀업 방식으로 사용하는것을 권장하는게 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.)

'''
정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
1) X가 5로 나누어떨어지면, 5로 나눈다.
2) X가 3으로 나누어떨어지면, 3으로 나눈다.
3) X가 2로 나누어떨어지면, 2로 나눈다.
4) X에서 1을 뺀다.

정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.

1. 26 - 1 = 25 (4)
2. 25 / 5  = 5 (1)
3. 5 / 5 = 1 (1)

입력 조건: 첫째 줄에 정수 X가 주어진다.
출력 조건: 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

입력 예시: 26
출력 예시: 3
'''

#!/usr/bin/env python3
num = int(input())
count = [0] * (num+1)  # num까지의 연산 횟수를 저장할 배열

def calculate(x):
    if x == 1:
        return 0  # 1일 때는 연산이 필요 없으므로 0 반환

    for i in range(2, x+1):
        count[i] = count[i-1] + 1  # 1을 빼는 연산
        if i % 2 == 0:
            count[i] = min(count[i], count[i//2]+1)
        if i % 3 == 0:
            count[i] = min(count[i], count[i//3]+1)
        if i % 5 == 0:
            count[i] = min(count[i], count[i//5]+1)
    return count[x]

print(calculate(num))

'''
개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정하자.
[1, 3, 1, 5]

이때 개미 전사는 두 번째 식ㄷ량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사는ㄴ 식량창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원한다.
개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하시오.

입력조건
    1. 첫째 줄에 식량창고의 개수 N이 주어진다 (3 < = N <= 100)
    2. 둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다. (0<=K<=1,000)
출력조건
    1. 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.

입력 예시

4
1 3 1 5

출력 예시

8
'''

#!/usr/bin/env python3
# 정수 N을 입력하기
n = int(input())
# 모든 식량 정보 입력받기
array= list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0]*100

# 다이냐믹 프로그래밍(Dynamic Programming)진행 (바텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n)
    d[i] = max(d[i-1], d[i-2]+array[i])

# 계산된 결과 출력
print(d[n - 1])

'''
가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1 x 2의 덮개, 2 x 1의 덮개, 2 x 2의 덮개를 이용해 채우고자 한다.

이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2x3 크기의 바닥을 채우는 경우의 수는 5가지이다.

입력조건: 첫째 줄에 N이 주어진다. (1 <= N <= 1,000)
출력조건: 첫째 줄에 2 X N 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.

입력 예시: 3
출력 예시: 5
'''

#!/usr/bin/env python3
n = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 1001

# 다이나믹 프로그래밍(Dynamic Programming) 진행(바텀업)
d[1] = 1
d[2] = 3
for i in range(3, n+1):
    d[i] = (d[i-1]+2*d[i-2])%796796

# 계산된 결과 출력
print(d[n])